\documentclass[a4paper]{article}
%--------------------%
% Including packages %
%--------------------%
\usepackage{Sweave}
\usepackage{url}
\usepackage[dutch]{babel}
%-----------------%
% Setting margins %
%-----------------%
\addtolength{\oddsidemargin}{-.25in}
\addtolength{\evensidemargin}{-.25in}
\addtolength{\textwidth}{.5in}
%-----------------%
% Some basic info %
%-----------------%
\title{Screenscrape project}
\author{G.T Gaastra, 1532162}
\date{\today}


\begin{document}

%-----------%
% Titelblad %
%-----------%
\maketitle

%--------------%
% Sweave setup %
%--------------%

\section*{Introductie}

Met de steeds verder snellere ontwikkeling van technieken in de moleculaire biologie waarin data wordt gegenereerd worden ook automatisch de vraag naar goede data analyse groter. Een vaak terugkerden onderdeel van deze analyses is het, vaak op grote schaal, BLASTen. Voluit staat BLAST voor Basic Local Alignment Search Tool en bestaat uit een verzameling algorithmes om biologische sequenties met elkaar te vergelijken. BLAST kan bijvoorbeeld gebruikt worden wanneer van een stuk genetische code wilt weten of er al vergelijkbare sequenties bekend zijn, en zo ja, wat zijn deze in hoe vergelijkbaar zijn deze?

Een van de technieken waarbij tijdens de data analyse op grote schaal vraag kan zijn naar het uitvoeren van BLASTs zijn microarrays. Bij deze arrays worden veel probes (DNA/RNA sequenties van ongeveer 25 tot 100 nucleotiden lang) gebruikt. Wanneer van deze probes de locatie op het genoom niet bekend is kan BLAST hierbij uitkomst bieden. Echter is dit zonder goede automatisering een lastige klus gezien de aantallen probes makkelijk in de tienduizenden kan lopen. 

\section*{Methode}

Een van de doelen van het screenscrape project was het verzamelen schrijven en verzamelen van functies voor R\cite{Rcran} die het verwerken waarbij grote datasets met sequenties op een gemakkelijke en repliceerbare manier kunnen worden geBLAST.  Om deze functies uiteindelijk goed beschikbaar te maken is er gekozen om deze binnen een zogenaamd R Package, genaamd BLASTnParse, te verzamelen.

\section*{BLAST via webformulier}

De eerste benadering om een deel van dit probleem op te lossen was het uitzoeken hoe het BLAST formulier van wormbase\cite{Wormbase} via R aangesproken kon worden. Om de site binnen R aan te kunnen spreken is $postForm$ van het R-pakket RCurl\cite{RCurl} gekozen. In het pakket BLASTnParse is de functie wormGetPos opgenomen waarin een query naar wormbase kan worden gedaan en die een lijst teruggeeft aan de gebruiker. De functie $BLASTthalina$ is vergelijkbaar maar stuurt de resultaten door naar Arabidopsis.org\cite{Arab}. Zie onderstaaande voorbeelden.

\begin{Schunk}
\begin{Sinput}
> ## Send Query to wormblast.org
> wormGetPos( query="TCGAGACGCGATGAAACA" )
\end{Sinput}
\begin{Soutput}
$V
     bp-mapped  length matched
[1,] "17649157" "15"          
\end{Soutput}
\begin{Sinput}
> ## Send Query to arabidopsis.org
> BLASTthaliana( ID="queryID", query="GACCCGAGAAAATCCAAGACCTATG" )
\end{Sinput}
\begin{Soutput}
        Query id       Subject id         identity alignment length 
       "queryID"           "F6F3"         "100.00"             "25" 
      mismatches     gap openings         q. start           q. end 
             "0"              "0"              "1"             "25" 
        s. start           s. end          e-value        bit score 
         "58525"          "58549"          "1e-06"           "50.1" 
\end{Soutput}
\end{Schunk}

\section*{NCBI qblast}
Een in potentie meer generieke oplossing is het vanuit R aanspreken van Qblast\cite{qblast}, een online api van NCBI om

\begin{Schunk}
\begin{Sinput}
> ## build input
> input <- matrix(c("ID1","ID2","CTTCGTTTCCCTCTTCTGCGATTTC","GATTGCACCTTCGATGGCCCTGAAA"),2,2)
> ## send BLASTs
> NCBIblast(input)